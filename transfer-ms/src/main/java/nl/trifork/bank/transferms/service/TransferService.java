package nl.trifork.bank.transferms.service;

import com.netflix.ribbon.proxy.annotation.Http;
import nl.trifork.bank.transferms.DAO.TransferDAO;
import nl.trifork.bank.transferms.client.AccountClient;
import nl.trifork.bank.transferms.exception.TransferException;
import nl.trifork.bank.transferms.model.Account;
import nl.trifork.bank.transferms.model.Transfer;

import org.omg.CORBA.TRANSACTION_MODE;
import org.slf4j.Logger; //logback
import org.slf4j.LoggerFactory;
import org.slf4j.Marker;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.RequestEntity;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Date;

@Service
@Transactional(rollbackFor = TransferException.class)
public class TransferService {
    private TransferDAO transferDAO;
    private AccountClient accountClient;
    private final static Logger logger = LoggerFactory.getLogger(TransferService.class);
    private ResponseEntity<Account> issuer;
    private ResponseEntity<Account> receiver;


    /**
     * Constructor for doing dependency injection
     *
     * @param transferDAO The transfer data access object to manipulate the database
     */
    @Autowired  // This means to get the bean called TransactionDAO
    // Which is auto-generated by Spring, we will use it to handle the data
    public TransferService(TransferDAO transferDAO, AccountClient accountClient) {
        this.transferDAO = transferDAO;
        this.accountClient = accountClient;
    }

    /**
     * Creates a transfer from the input of the body of the request.
     *
     * @param transfer Transfer object
     * @return The transfer that has just been saved
     */
    public ResponseEntity<?> createTransfer(Transfer transfer) {
        // Request the accounts from the account-ms
        System.out.println("test");
        issuer = accountClient.findByKey(String.valueOf(transfer.getFrom_key()));
        receiver = accountClient.findByKey(String.valueOf(transfer.getTo_key()));
        // First the transfer needs to be verified
        verifyTransfer(transfer);
        String ifMatch = issuer.getHeaders().getETag();
        // Then the transfer will be saved
        transfer.setCreatedAt(new Date());
        transferDAO.save(transfer);

        // Execute the transfer between the accounts
        ResponseEntity<?> response = accountClient.executeTransfer(ifMatch, transfer);


        if (response.getStatusCode() == HttpStatus.OK) {
            return ResponseEntity
                    .ok()
                    .body(transfer);
        } else {
            throw new TransferException(response.getStatusCode().getReasonPhrase());
        }
    }


    /**
     * Verifies if the amount of the transfer does not exceed the Issuer's balance
     *
     * @param transfer object
     */
    private void verifyTransfer(Transfer transfer) {
        long amount = transfer.getAmount();

        // Verify if the httpresponse codes are valid
        if (issuer.getStatusCode() != HttpStatus.OK || receiver.getStatusCode() != HttpStatus.OK) {
            throw new TransferException("The status codes are not valid");
        }
        // Verify if the account's are legit
        if (receiver.getBody() == null || issuer.getBody() == null) {
            throw new TransferException("Either one of the accounts doesn't exist");
        }
        // Check if the transfer is legit
        if (amount > issuer.getBody().getBalance())
            throw new TransferException("Balance is too low");

    }

    public Transfer findTransfer(long id) {
        return transferDAO.findOne(id);
    }

    public Iterable<Transfer> findAllTransfers() {
        return transferDAO.findAll();
    }
}
